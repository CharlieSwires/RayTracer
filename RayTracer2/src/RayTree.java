import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class RayTree {
	public static int depth;


	/******************************************************************************/
	/*                                                                            */
	/* TITLE :  Testbed Raytracer (final year project)                            */
	/* CREATOR: C.E.L. Swires                                                     */
	/* DATE:    6/4/1990                                                          */
	/*                                                                            */
	/* FILE: rt.c                                                                 */
	/*                                                                            */
	/* FUNCTION  : rtree()                                                        */
	/*                                                                            */
	/* RETURNED VALUE : returns double representing brightness (luminosity) for a  */
	/*                  ray                                                       */
	/*                                                                            */
	/* DESCRIPTION : this function  performs the raytracing. The procedure takes  */
	/* a ray generated by the raygen function, and then checks the interaction    */
	/* of this ray with the scene. Reflected and refracted rays are generated if  */
	/* the initial ray collides with a reflective or transparent material.        */
	/*                                                                            */
	/* This function is recursive, calling its self with the newly generated rays */
	/* until the max ray depth is reached.                                        */
	/*                                                                            */
	/* FUNCTIONS CALLED : rayalloc() dotv() subv() normv() modv() Fr() Ft()       */
	/* reflect() refract() rtree() contact()                                      */
	/*                                                                            */
	/* RELATED DOCUMENTS :                                                        */
	/*                                                                            */
	/******************************************************************************/

	private static final double OBST_THRESH = 0.999999;
	private static final double AMBIENT = 50.0;
	private static final double SPEC_THRESH = 0.000000001;
	private static final double REFL_THRESH = 0.000000001;
	private static final double TRANS_THRESH = 0.000000001;
	private static final double VALID_COL= 1e-4;

	/*____________________________________________________________________________*/

	public static double rtree(Raynode ray,Enviro env)

	/* present ray */
	/* pointer to the structure of starting pointers */
	{
		Contactpt col=new Contactpt();           /* ray from light source collision */
		Contactpt collision=new Contactpt();     /* present ray collision */
		Raynode lray=new Raynode();            /* ray from light source */
		Raynode newray=new Raynode();         /* new ray */
		Lights ls= new Lights();              /* light source */

		double normal[]=new double[3];/* unit normal vector to surface which present ray */
		/* collided  with */
		double view[]= new double[3];  /* unit direction vector of viewing ray */
		/* (ie present ray)*/
		double tmp[]=new double[3];   /* temporary vector used in calculations*/
		double L[]=new double[3];     /* vector from light source */
		double H[]=new double[3];     /* reflected or refracted view vector */

		double sum;      /* total contribution from light sources */
		double sum1;     /* total diffuse  from light sources */
		double sum2;     /* total reflected specular from light sources */
		double sum3;     /* total transmitted specular from light sources */
		double absorb;   /* absorbance of material, ray has just travelled in*/
		double drt;      /* dist from ray origin to collision point */
		double rind;     /* refractive index of material */
		double Rd;       /* diffuse reflectance of material */
		double n;        /* shinyness of material, represented as a power */
		double ks;       /* specular contribution to intensity */
		double kd;       /* diffuse contribution to intensity */
		double alpha;    /* value returned by contact */
		double Ij;       /* illumination from j th light source */
		double Ia;       /* estimated ambient illumination */
		double ldist;    /* distance from light source to collision point */
		double LN;       /* dot product of L and normal */
		double VN;       /* dot product of view and normal */
		double VH;       /* dot product of view and H */
		double Rf=0.0;       /* Fresnel value of reflectance */
		double Tf=0.0;       /* Fresnel value of transmittance */
		double transray; /* luminosity of transmitted ray */
		double reflray;  /* iuminosity of reflected ray */
		double diffuse;  /* diffuse component from light source */
		double attenuation;      /* energy lost from ray due to material */
		double total;    /* sum of all contributions including refracted and */
		if (ray == null) return (0.0);  /* should never happen */
		if (ray.depth < 1) return (0.0);/* top of tree */

		if (contact (ray, env, collision) < 0.0) {
			double lightFromLS = 0.0;

			if (ray.depth == RayTree.depth){
				Lights l = env.li;
				while(l != null){
					double vectorToLight[] = new double[3];
					VectorAlgebra.subv(l.co, ray.ri, vectorToLight);
					double length = VectorAlgebra.modv(vectorToLight);
					VectorAlgebra.normv(vectorToLight);
					double raydir[]=new double[3];
					VectorAlgebra.copyv(raydir, ray.rd);
					VectorAlgebra.normv(raydir);
					double dotRayLight = VectorAlgebra.dotv(raydir,vectorToLight);
					if (dotRayLight < 0.0)
						dotRayLight = 0.0;
					lightFromLS += (l.power/(length*length))*Math.pow(dotRayLight, 10000);
					l=l.next;
				}
			}
			lightFromLS+=env.sky.rdiff(ray.rd)*10000.0;
			return lightFromLS;
		}

		/* no collision ret 0 */

		VectorAlgebra.copyv (normal, collision.norm); /* pull normal and view from collision*/
		VectorAlgebra.normv (normal);                 /* and ray respectively */
		VectorAlgebra.copyv (view, ray.rd);
		VectorAlgebra.normv (view);


		if(collision.mats == null && collision.matt == null && collision.matts == null && collision.mpc == null)
			ks = (collision.mat.pcentmir) / 100.0;
		else if (collision.mats != null)
			ks = (collision.mats.pcntshiny(normal)*collision.mat.pcentmir / 10000.0);
		else if (collision.matts != null){
			double complexObjNorm[] = new double[3];
			VectorAlgebra.subv(collision.cc, collision.matts.origin, complexObjNorm);
			ks = (collision.matts.pcntshiny(complexObjNorm)*collision.mat.pcentmir / 10000.0);
		}
		else if (collision.mpc != null){
			double complexObjNorm[] = new double[3];
			VectorAlgebra.subv(collision.cc, collision.mpc.origin, complexObjNorm);
			ks = (collision.mpc.pcntshiny(complexObjNorm)*collision.mat.pcentmir / 10000.0);
		}
		else
			ks = (collision.matt.pcntshiny(collision.cc)*collision.mat.pcentmir / 10000.0);
		/* calculate ks, kd for material */
		/* in collision */
		kd = 1.0 - ks;
		n = collision.mat.smooth;      /* pull n,Rd,rind from material */
		Rd = collision.mat.Rd;
		rind = collision.mat.refi;

		/* calc distance ray travelled */
		drt = VectorAlgebra.modv (VectorAlgebra.subv (collision.cc, ray.ri, tmp));

		/* workout in which material the ray*/
		/* travelled in */
		if (VectorAlgebra.dotv (normal, view) > 0.0) absorb = collision.mat.mat1;
		else absorb = collision.mat.mat2;

		Ia = AMBIENT;

		sum1 = sum2 = sum3 = 0.0;
		ls = env.li;

		while (ls != null){

			VectorAlgebra.subv (collision.cc, ls.co, L); /* workout lray (light source*/
			VectorAlgebra.copyv (lray.ri, ls.co);        /* ray */
			VectorAlgebra.copyv (lray.rd, L);

			alpha = contactLights (lray, env, col);

			if (alpha > 0 && alpha <= OBST_THRESH);
			/*light ray obstructed */
			/* do nothing */

			else{                           /* light source effective */
				/* illumination at collision*/
				ldist = VectorAlgebra.modv (L);
				Ij = ls.power*col.frTransmission / (ldist*ldist);

				VectorAlgebra.normv(L);
				LN = VectorAlgebra.dotv (L, normal);
				VN = VectorAlgebra.dotv (view, normal);


				/* if view ray and light source ray */
				/* are on same side of the material */

				if ( (LN<0.0 && VN<0.0) || (LN>0.0 && VN>0.0) ) {

					/* calculate Fresnel reflectance value*/
					/* before L.N is converted to +ve real*/
					/* calculate diffuse component and add*/
					/* to sum1 */

					Rf = VectorAlgebra.Fr(LN,rind);
					LN = (LN<0.0) ? -LN : LN;

					if (collision.mats==null && collision.matt == null && collision.matts == null && collision.mpc == null)
						diffuse = Rd*Ij*LN;
					else if (collision.mats != null)
						diffuse = Rd*Ij*LN*collision.mats.rdiff(normal);
					else if (collision.mpc != null){
						double complexObjNorm[] = new double[3];
						VectorAlgebra.subv(collision.cc, collision.mpc.origin, complexObjNorm);
						diffuse = Rd*Ij*LN*collision.mpc.rdiff(complexObjNorm);
					}
					else if (collision.matts != null){
						double complexObjNorm[] = new double[3];
						VectorAlgebra.subv(collision.cc, collision.matts.origin, complexObjNorm);
						diffuse = Rd*Ij*LN*collision.matts.rdiff(complexObjNorm);
					}
					else
						diffuse = Rd*Ij*LN*collision.matt.rdiff(collision.cc);

					sum1 = sum1 + diffuse;

					if (ks > SPEC_THRESH){

						/*light source specular is significant*/

						/* reflect L giving H */
						/* calculate specualr illumination */
						/* from light source and add to sum2*/

						VectorAlgebra.reflect (L, normal, H);
						VH = -(VectorAlgebra.dotv (view, H));
						VH = (VH<0.0) ? 0.0 : VH;
						sum2 = sum2 + Rf*Ij*Math.pow(VH,n);
					}

				}

				/* light source and viewer on opposite sides */

				else if (ks > SPEC_THRESH){

					/*light source specular is significant*/

					/* workout Fresnel transmittance Tf */
					/* refract L giving H */
					/* then using V.H workout specular */
					/* from light source and add to sum3 */

					Tf = VectorAlgebra.Ft(LN,rind);
					VectorAlgebra.refract(L,normal,H,rind);
					VH = -(VectorAlgebra.dotv(view,H));
					VH = (VH<0.0) ? 0.0 : VH;
					sum3 = sum3 + Tf*Ij*Math.pow(VH,n);
				}
			}
			ls = ls.next;  /* next light source */

		}/* end of while loop */

		/* add all light source contributions*/
		sum = kd*sum1 + Rd*Ia + ks*( sum2 + sum3);

		/* work out contribution from reflected ray */

		if (ks < SPEC_THRESH)
			/* specular contribution insignificant */

			transray = reflray = 0.000;

		else {          /* significant specular contribution */

			VN = VectorAlgebra.dotv (view, normal);
			Rf = VectorAlgebra.Fr (VN, rind);


			/* generate a significant reflected */
			/* ray */
			if (Rf > REFL_THRESH) {

				newray = new Raynode();;
				/* calc ray direction */
				VectorAlgebra.copyv (newray.rd, VectorAlgebra.reflect (view, normal, tmp));

				/* ray start pt = collision */
				VectorAlgebra.copyv (newray.ri, collision.cc);

				newray.depth = ray.depth - 1;

				/* recursive call to work out*/
				/* brightness of reflected ray*/
				reflray = rtree (newray, env);

				/* free space taken by ray */

			}

			else reflray = 0;

			/* work out transmitted ray*/

			VN = VectorAlgebra.dotv (view, normal);
			Tf = VectorAlgebra.Ft (VN, rind);

			/* generate a significant refracted */
			/* ray */
			if (Tf > TRANS_THRESH) {

				newray = new Raynode();

				/* calc refracted direction */
				VectorAlgebra.copyv (newray.rd, VectorAlgebra.refract (view, normal, tmp, rind));

				/* start position = collision */
				/* point */
				VectorAlgebra.copyv (newray.ri, collision.cc);

				newray.depth = ray.depth - 1;

				/* recursive call to calculate the */
				/* refracted ray's brightness */
				transray = rtree (newray, env);

				/* remove ray from ray tree */
			}

			else transray = 0.0;
		}

		attenuation = Math.pow (absorb, drt);        /* work out light lost into */
		/* the medium in which the */
		/* ray traveled */

		total = sum + ks*( Rf*reflray + Tf*transray);   /* workout total light*/
		/* contributions */

		return (attenuation * total);   /* return final brightness */
	}

	/******************************************************************************/
	/*                                                                            */
	/* FUNCTION : contact()                                                       */
	/*                                                                            */
	/* RETURN VALUE : this is the double value alpha, where alpha is the scalar    */
	/*                value from rscol or rtcol.                                  */
	/*                                                                            */
	/* DESCRIPTION :  This function finds the first collision wich occurs with    */
	/* the ray. If a collision occurs then the information about the collision    */
	/* is stored in contpt (normal of surface, material and co-ordinate)          */
	/*                                                                            */
	/* FUNCTIONS CALLED : rtcol() rscol() mulv() addv() subv()                    */
	/*                                                                            */
	/* RELATED DOCUMENTS :                                                        */
	/*                                                                            */
	/******************************************************************************/


	private static double contact(Raynode ray,Enviro env,Contactpt contpt)

	/* ray to check for a collision */
	/* pointer to enviroment primitives */
	/* structure in which to place the results */

	{
		Triangle tr=new Triangle();    /* pointer to triangle in the linked list */
		Triangle tbest=new Triangle(); /* pointer to the nearest triangle */
		Cylinder cy=null;    /* pointer to cylinder in the linked list */
		Cylinder cbest=null; /* pointer to the nearest cylinder */
		Disk dc=null;    /* pointer to disk in the linked list */
		Disk dbest=null; /* pointer to the nearest disk */
		Sphere sp=new Sphere();      /* pointer to a sphere in the linked list */
		Sphere sbest=new Sphere();   /* pointer to the nearest sphere */
		double nearest;          /* the smallest positive value of alpha so far*/
		double alpha = -1.0;            /* scalar value returned by rscol and rtcol */

		nearest = -1.0;
		tbest = null;
		tr=env.ti;             /* set tr to first triangle in list */

		BoundingParallelpiped bv = env.bpi;
		//		/*
		//		 * if (env.bv != null)
		if (bv != null){
		
			bv.tested= false;
			//		 * do {
			do {
				//		 * 	for all bv in level{
				if (!bv.tested){
					if(bv.containsbv != null)for (BoundingParallelpiped btest:bv.containsbv){
						//		 * 		test for intersection store alpha
						VectorAlgebra.bvcol(ray.ri, ray.rd, btest);
												//		 * 		set tested to false

						btest.tested = false;
						//		 * 	}
					}
					//				 * 	sort bv
					//Collections.sort(bv.containsbv,BoundingParallelpiped.alphaComparator);
				}
				//		 * 	select first bv not already tested and alpha > 0 set tested = true
				boolean found = false;
				BoundingParallelpiped bvtemp=null;
				if(bv.containsbv != null){
					bvtemp = bv.containsbv.get(0);
					for (BoundingParallelpiped btest:bv.containsbv){
						if (!btest.tested&& btest.inside && btest.alpha > VALID_COL){
							bvtemp = btest;
							found = true;
							break;
						}
					}
				}
				else if(!bv.tested){
					found = true;
					bvtemp = bv;
				}
				bv.tested = true;
				//				 *  if no more bv then set bv to parent and continue
				if (!found){
					bv = bv.parentbv;
					if (bv == null){
						return nearest;
					}
				}else{
					//				 * 	set bv to children
					bv = bvtemp;
					bv.tested = false;

					//		 * 	if bv == null then search elements
					if ((bv.containsbv == null || bv.containsbv.isEmpty())){
						//					 * 	return normal and alpha of closest collision
						Contactpt bestContpt1 = new Contactpt();
						double alpha1 = collisionWithElements(ray,bv,bestContpt1,false);
						if (alpha1 > VALID_COL) {
							if (nearest <= 0.0){
								nearest = alpha1;
								contpt.copy(bestContpt1);
							}else if (alpha1 < nearest){
								nearest = alpha1;
								contpt.copy(bestContpt1);
							}
						}
						bv.tested=true;
					}
				}
				//		 * } while (true);
			}while (true);
			//		 * else
			//		 * old way
			//		 */
		}
		else {
		
			nearest = collisionWithElements(ray,env,contpt,false);
			
			return (nearest);
		}
	}
	private static double collisionWithElements(Raynode ray, Enviro env, Contactpt contpt, boolean lights) {
		double nearest = -1.0;
		Triangle tbest = null;
		double alpha;
		double frTransmission = 1.0;
		/* set tr to first triangle in list */

		Triangle tr = env.ti;
		while(tr != null){
			/* calculate if ray collides with the*/
			/* triangle tr */
			alpha = rtcol (ray.ri, ray.rd, tr);

			if (alpha > VALID_COL) {
				double point[] = new double[3];double relative[] = new double[3];
				point = VectorAlgebra.addv(ray.ri,VectorAlgebra.mulv(alpha, ray.rd, point),point);
				double norm[] = new double[3];
				double rd[] = new double[3];
				VectorAlgebra.copyv (norm, tr.pl);
				VectorAlgebra.normv(norm);
				VectorAlgebra.copyv (rd, ray.rd);
				VectorAlgebra.normv(rd);
				double cosi = VectorAlgebra.dotv(rd, norm);
				double frt = VectorAlgebra.Ft(cosi, tr.mat.refi);
					/* collision in forward dir of ray */
				boolean wayClear =(tr.mat.refi >= 0.5 && 
						tr.mat.refi<=2.0 &&
						((tr.mats != null && tr.mats.pcntshiny(VectorAlgebra.subv(point,tr.mats.origin,relative))>50.0)|| (tr.mats == null &&tr.mat.pcentmir >50.0))&&
						((tr.matt != null && tr.matt.pcntshiny(point)>50.0)|| (tr.matt == null &&tr.mat.pcentmir >50.0)));
				frTransmission *= (wayClear&&lights&&alpha < 1.0?frt:1.0);
			if((!lights || !wayClear)/*|| frt < 0.02*/) {
					
					if (nearest <=0.0) {
						/* nearest not set with valid value */

						nearest = alpha;
						tbest = tr;
					}

					else if (alpha < nearest) {
						/* nearest is worse than */
						/*new  value */

						nearest = alpha;
						tbest = tr;
					}
				}
				tr =tr.next;
			}/* end of valid collision if */


		}/* end of while loop, for triangle list */

		Sphere sbest = null;

		Sphere sp = env.si;
		while(sp != null){

			alpha = VectorAlgebra.rscol (ray.ri, ray.rd, sp.r_cnt);

			if (alpha > VALID_COL){
				/* calculate point of collision */
				double temp[] = new double[3];
				VectorAlgebra.mulv (alpha, ray.rd, temp);
				VectorAlgebra.addv (temp, ray.ri, temp);

				VectorAlgebra.subv (temp, sp.r_cnt, temp);
				if(VectorAlgebra.modv(temp)>0)
					VectorAlgebra.normv(temp);
				double rd[] = new double[3];
				VectorAlgebra.copyv (rd, ray.rd);
				VectorAlgebra.normv(rd);
				double cosi = VectorAlgebra.dotv(rd, temp);
				double frt = VectorAlgebra.Ft(cosi, sp.mat.refi);
				boolean wayClear =(sp.mat.refi >= 0.5 && 
						sp.mat.refi<=2.0 &&
						((sp.mats != null && sp.mats.pcntshiny(temp)>50.0)|| (sp.mats == null &&sp.mat.pcentmir >50.0)));
				frTransmission *= (wayClear&&lights&&alpha < 1.0?frt:1.0);
				if((!lights ||!wayClear) /*|| frt < 0.02*/) {
					/* valid collision with sphere */
					
					if (nearest <= 0) {
						/* nearest value invalid */

						nearest = alpha;
						sbest = sp;
						tbest = null;
					}

					else if (alpha < nearest) {
						/* nearest worse than alpha */

						nearest = alpha;
						sbest = sp;
						tbest = null;
					}
				}
			}/* end of valid collision if */
			sp=sp.next;
		}/* end of sphere while loop */
		Cylinder cbest = null;

		Cylinder cy = env.ci;
		while(cy != null){

			alpha = cy.rccol (ray.ri, ray.rd);
			double temp[] = new double[3];
			VectorAlgebra.mulv (alpha, ray.rd, temp);
			VectorAlgebra.addv (temp, ray.ri, temp);

			VectorAlgebra.subv (temp, cy.position, temp);
			VectorAlgebra.subv (contpt.cc, cy.position, contpt.norm);
			double tmp[] = new double[3];double tmp2[] = new double[3];
			VectorAlgebra.mulv(VectorAlgebra.dotv(cy.uxInv, contpt.norm),cy.uxInv,tmp);
			VectorAlgebra.mulv(VectorAlgebra.dotv(cy.uyInv, contpt.norm),cy.uyInv,tmp2);
			VectorAlgebra.addv(tmp2, tmp, contpt.norm);
			VectorAlgebra.normv(contpt.norm);
			if (alpha > VALID_COL){
				/* calculate point of collision */
				/* valid collision with sphere */
				double rd[] = new double[3];
				VectorAlgebra.copyv (rd, ray.rd);
				VectorAlgebra.normv(rd);
				double cosi = VectorAlgebra.dotv(rd,contpt.norm);
				double frt = VectorAlgebra.Ft(cosi, cy.mat.refi);
				boolean wayClear =(cy.mat.refi >= 0.5 && 
						cy.mat.refi<=2.0 &&
						((cy.mpc != null && cy.mpc.pcntshiny(temp)>50.0)|| (cy.mpc == null &&cy.mat.pcentmir >50.0)));
				frTransmission *= (wayClear&&lights&&alpha < 1.0?frt:1.0);
				if((!lights ||!wayClear) /*|| frt < 0.02*/) {
					/* valid collision with sphere */
					
					if (nearest <= 0) {
						/* nearest value invalid */

						nearest = alpha;
						cbest = cy;
						tbest = null;
						sbest = null;
					}

					else if (alpha < nearest) {
						/* nearest worse than alpha */

						nearest = alpha;
						cbest = cy;
						sbest = null;
						tbest = null;
					}
				}				
			}/* end of valid collision if */
			cy =cy.next;
		}/* end of sphere while loop */
		Disk dbest = null;

		Disk dc = env.di;
		while(dc != null){
			/* calculate if ray collides with the*/
			/* dciangle dc */
			alpha = dc.rdcol (ray.ri, ray.rd);
			if (alpha > VALID_COL) {
				double point[] = new double[3];double relative[] = new double[3];
				point = VectorAlgebra.addv(ray.ri,VectorAlgebra.mulv(alpha, ray.rd, point),point);
				double norm[] = new double[3];
				double rd[] = new double[3];
				VectorAlgebra.copyv (norm, dc.pl);
				VectorAlgebra.normv(norm);
				VectorAlgebra.copyv (rd, ray.rd);
				VectorAlgebra.normv(rd);
				double cosi = VectorAlgebra.dotv(rd, norm);
				double frt = VectorAlgebra.Ft(cosi, dc.mat.refi);
				boolean wayClear =(dc.mat.refi >= 0.5 && 
						dc.mat.refi<=2.0 &&
						((dc.mtt != null && dc.mtt.pcntshiny(point)>50.0)|| (dc.mtt == null &&dc.mat.pcentmir >50.0)));
				frTransmission *= (wayClear&&lights&&alpha < 1.0?frt:1.0);
				if((!lights ||!wayClear) /*|| frt < 0.02*/) {
				/* collision in forward dir of ray */
					
					if (nearest <=0.0) {
						/* nearest not set with valid value */

						nearest = alpha;
						dbest = dc;
						sbest = null;
						tbest = null;
						
						cbest = null;
					}

					else if (alpha < nearest) {
						/* nearest is worse than */
						/*new  value */

						nearest = alpha;
						dbest = dc;
						sbest = null;
						tbest = null;
						cbest = null;
					}
				}

			}/* end of valid collision if */
			dc =dc.next;
		}/* end of while loop, for dciangle list */


		if (nearest <= 0.0) return (-1.0);  /* nearest invalid the return -1 */

		/* calculate point of collision */
		VectorAlgebra.mulv (nearest, ray.rd, contpt.cc);
		VectorAlgebra.addv (contpt.cc, ray.ri, contpt.cc);

		if (tbest != null) {
			/* if the collision occured with a triangle */
			/* then get normal and material from triangle */

			VectorAlgebra.copyv (contpt.norm, tbest.pl);
			VectorAlgebra.normv(contpt.norm);
			contpt.mat = tbest.mat;
			contpt.mats = null;
			contpt.matt=tbest.matt;
			contpt.matts=tbest.mats;
			contpt.mpc = null;

		}

		else if (sbest != null) {
			/* if the collision occured with a sphere then*/
			/* calculate the normal and get material from */
			/* sphere */

			VectorAlgebra.subv (contpt.cc, sbest.r_cnt, contpt.norm);
			VectorAlgebra.normv(contpt.norm);
			contpt.mat = sbest.mat;
			contpt.mats = sbest.mats;
			contpt.matt = null;
			contpt.matts= null;
			contpt.mpc = null;
		}
		else if (cbest != null) {
			/* if the collision occured with a cylinder then*/
			/* calculate the normal and get material from */
			/* cylinder */

			VectorAlgebra.subv (contpt.cc, cbest.position, contpt.norm);
			double tmp[] = new double[3];double tmp2[] = new double[3];
			VectorAlgebra.mulv(VectorAlgebra.dotv(cbest.uxInv, contpt.norm),cbest.uxInv,tmp);
			VectorAlgebra.mulv(VectorAlgebra.dotv(cbest.uyInv, contpt.norm),cbest.uyInv,tmp2);
			VectorAlgebra.addv(tmp2, tmp, contpt.norm);
			VectorAlgebra.normv(contpt.norm);
			contpt.mat = cbest.mat;
			contpt.mats = null;
			contpt.matt = null;
			contpt.matts = null;
			contpt.mpc = cbest.mpc;
		}
		else if (dbest != null) {
			/* if the collision occured with a cylinder then*/
			/* calculate the normal and get material from */
			/* cylinder */

			VectorAlgebra.copyv (contpt.norm, dbest.pl);
			VectorAlgebra.normv(contpt.norm);
			contpt.mat = dbest.mat;
			contpt.mats = null;
			contpt.matt=dbest.mtt;
			contpt.matts=null;
			contpt.mpc = null;
		}

		else {  /* should never happen for a valid scene */

			System.out.println ("\n Error No Objects found in contact \n");
			System.exit (1);
		}
		contpt.frTransmission = frTransmission;
		return (nearest);
	}

	private static double contactLights(Raynode ray,Enviro env,Contactpt contpt)

	/* ray to check for a collision */
	/* pointer to enviroment primitives */
	/* structure in which to place the results */

	{
		Triangle tr=new Triangle();    /* pointer to triangle in the linked list */
		Triangle tbest=new Triangle(); /* pointer to the nearest triangle */
		Sphere sp=new Sphere();      /* pointer to a sphere in the linked list */
		Sphere sbest=new Sphere();   /* pointer to the nearest sphere */
		double nearest;          /* the smallest positive value of alpha so far*/
		double alpha = -1.0;            /* scalar value returned by rscol and rtcol */
		nearest = -1.0;

		BoundingParallelpiped bv = env.bpi;
		//		/*
		//		 * if (env.bv != null)
		if (bv != null){
			bv.tested= false;
			//		 * do {
			do {
				//		 * 	for all bv in level{
				if (!bv.tested){
					if(bv.containsbv != null)for (BoundingParallelpiped btest:bv.containsbv){
						//		 * 		test for intersection store alpha
						VectorAlgebra.bvcol(ray.ri, ray.rd, btest);
						//		 * 		set tested to false

						btest.tested = false;
						//		 * 	}
					}
					//				 * 	sort bv
					//Collections.sort(bv.containsbv,BoundingParallelpiped.alphaComparator);
				}
				//		 * 	select first bv not already tested and alpha > 0 set tested = true
				boolean found = false;
				BoundingParallelpiped bvtemp = null;
				if(bv.containsbv != null){
					bvtemp = bv.containsbv.get(0);
					for (BoundingParallelpiped btest:bv.containsbv){
						if (!btest.tested&& btest.inside && btest.alpha > VALID_COL){
							bvtemp = btest;
							found = true;
							break;
						}
					}
				}
				else if(!bv.tested){
					found = true;
					bvtemp = bv;
				}
				bv.tested = true;
				//				 *  if no more bv then set bv to parent and continue
				if (!found){
					bv = bv.parentbv;
					if (bv == null){

						return nearest;
					}
				}else{
					//				 * 	set bv to children
					bv = bvtemp;
					bv.tested = false;

					//		 * 	if bv == null then search elements
					if ((bv.containsbv == null || bv.containsbv.isEmpty())){
						//					 * 	return normal and alpha of closest collision
						//						System.out.println("Spheres = "+(bv.containsSpheres != null?bv.containsSpheres.size():0)+
						//								"Triangles = "+(bv.containsTriangles != null?bv.containsTriangles.size():0));
						Contactpt bestContpt1 = new Contactpt();
						double alpha1 = collisionWithElements(ray,bv,bestContpt1,!RayTracerMain.TRANSPARENCIES_HAVE_SHADOWS);
						if (alpha1 > VALID_COL) {
							if (nearest <= 0.0){
								nearest = alpha1;
								contpt.copy(bestContpt1);
								//if (bestContpt1.mat.refi > 1.25 && bestContpt1.mat.refi < 1.35)System.out.println("tr "+alpha);
							}else if (alpha1 < nearest){
								nearest = alpha1;
								contpt.copy(bestContpt1);
								//if (bestContpt1.mat.refi > 1.25 && bestContpt1.mat.refi < 1.35)System.out.println("tr "+alpha);
							}
						}
						bv.tested =true;

					}
				}
				//		 * } while (true);
			}while (true);
			//		 * else
			//		 * old way
			//		 */
		}
		else {
			nearest = collisionWithElements(ray,env,contpt,!RayTracerMain.TRANSPARENCIES_HAVE_SHADOWS);
			return (nearest);
		}
	}


	private static double collisionWithElements(Raynode ray, BoundingParallelpiped bv, Contactpt contpt, boolean lights) {
		double nearest = -1.0;
		Triangle tbest = null;
		double alpha;
		double frTransmission = 1.0;
		/* set tr to first triangle in list */

		if(bv.containsTriangles!=null) for (Triangle tr:bv.containsTriangles){
			/* calculate if ray collides with the*/
			/* triangle tr */
			alpha = rtcol (ray.ri, ray.rd, tr);

			if (alpha > VALID_COL) {
				double point[] = new double[3];double relative[] = new double[3];
				point = VectorAlgebra.addv(ray.ri,VectorAlgebra.mulv(alpha, ray.rd, point),point);
				double norm[] = new double[3];
				double rd[] = new double[3];
				VectorAlgebra.copyv (norm, tr.pl);
				VectorAlgebra.normv(norm);
				VectorAlgebra.copyv (rd, ray.rd);
				VectorAlgebra.normv(rd);
				double cosi = VectorAlgebra.dotv(rd, norm);
				double frt = VectorAlgebra.Ft(cosi, tr.mat.refi);
				boolean wayClear =(tr.mat.refi >= 0.5 && 
						tr.mat.refi<=2.0 &&
						((tr.mats != null && tr.mats.pcntshiny(VectorAlgebra.subv(point,tr.mats.origin,relative))>50.0)|| (tr.mats == null &&tr.mat.pcentmir >50.0))&&
						((tr.matt != null && tr.matt.pcntshiny(point)>50.0)|| (tr.matt == null &&tr.mat.pcentmir >50.0)));
				frTransmission *= (wayClear&&lights&&alpha < 1.0?frt:1.0);
			if((!lights || !wayClear)/*|| frt < 0.02*/) {
					
					if (nearest <=0.0) {
						/* nearest not set with valid value */

						nearest = alpha;
						tbest = tr;
					}

					else if (alpha < nearest) {
						/* nearest is worse than */
						/*new  value */

						nearest = alpha;
						tbest = tr;
					}
				}

			}/* end of valid collision if */


		}/* end of while loop, for triangle list */

		Sphere sbest = null;

		if (bv.containsSpheres!=null)for(Sphere sp: bv.containsSpheres){

			alpha = VectorAlgebra.rscol (ray.ri, ray.rd, sp.r_cnt);

			if (alpha > VALID_COL){
				/* calculate point of collision */
				double temp[] = new double[3];
				VectorAlgebra.mulv (alpha, ray.rd, temp);
				VectorAlgebra.addv (temp, ray.ri, temp);

				VectorAlgebra.subv (temp, sp.r_cnt, temp);
				if(VectorAlgebra.modv(temp)>0)
					VectorAlgebra.normv(temp);
				double rd[] = new double[3];
				VectorAlgebra.copyv (rd, ray.rd);
				VectorAlgebra.normv(rd);
				double cosi = VectorAlgebra.dotv(rd, temp);
				double frt = VectorAlgebra.Ft(cosi, sp.mat.refi);
				boolean wayClear =(sp.mat.refi >= 0.5 && 
						sp.mat.refi<=2.0 &&
						((sp.mats != null && sp.mats.pcntshiny(temp)>50.0)|| (sp.mats == null &&sp.mat.pcentmir >50.0)));
				frTransmission *= (wayClear&&lights&&alpha < 1.0?frt:1.0);
				if((!lights ||!wayClear) /*|| frt < 0.02*/) {
					/* valid collision with sphere */
					
					if (nearest <= 0) {
						/* nearest value invalid */

						nearest = alpha;
						sbest = sp;
						tbest = null;
					}

					else if (alpha < nearest) {
						/* nearest worse than alpha */

						nearest = alpha;
						sbest = sp;
						tbest = null;
					}
				}
			}/* end of valid collision if */

		}/* end of sphere while loop */
		Cylinder cbest = null;

		if (bv.containsCylinders!=null)for (Cylinder cy :bv.containsCylinders){

			alpha = cy.rccol (ray.ri, ray.rd);
			double temp[] = new double[3];
			VectorAlgebra.mulv (alpha, ray.rd, temp);
			VectorAlgebra.addv (temp, ray.ri, temp);

			VectorAlgebra.subv (temp, cy.position, temp);
			VectorAlgebra.subv (contpt.cc, cy.position, contpt.norm);
			if (alpha > VALID_COL){
				/* calculate point of collision */
				/* valid collision with sphere */
				double tmp[] = new double[3];double tmp2[] = new double[3];
				VectorAlgebra.mulv(VectorAlgebra.dotv(cy.uxInv, contpt.norm),cy.uxInv,tmp);
				VectorAlgebra.mulv(VectorAlgebra.dotv(cy.uyInv, contpt.norm),cy.uyInv,tmp2);
				VectorAlgebra.addv(tmp2, tmp, contpt.norm);
				VectorAlgebra.normv(contpt.norm);
				double rd[] = new double[3];
				VectorAlgebra.copyv (rd, ray.rd);
				VectorAlgebra.normv(rd);
				double cosi = VectorAlgebra.dotv(rd,contpt.norm);
				double frt = VectorAlgebra.Ft(cosi, cy.mat.refi);
				boolean wayClear =(cy.mat.refi >= 0.5 && 
						cy.mat.refi<=2.0 &&
						((cy.mpc != null && cy.mpc.pcntshiny(temp)>50.0)|| (cy.mpc == null &&cy.mat.pcentmir >50.0)));
				frTransmission *= (wayClear&&lights&&alpha < 1.0?frt:1.0);
				if((!lights ||!wayClear) /*|| frt < 0.02*/) {
					/* valid collision with sphere */
					
					if (nearest <= 0) {
						/* nearest value invalid */

						nearest = alpha;
						cbest = cy;
						tbest = null;
						sbest = null;
					}

					else if (alpha < nearest) {
						/* nearest worse than alpha */

						nearest = alpha;
						cbest = cy;
						sbest = null;
						tbest = null;
					}
				}				
			}/* end of valid collision if */

		}/* end of sphere while loop */
		Disk dbest = null;

		if (bv.containsDisks!=null)for (Disk dc:bv.containsDisks){
			/* calculate if ray collides with the*/
			/* dciangle dc */
			alpha = dc.rdcol (ray.ri, ray.rd);
			if (alpha > VALID_COL) {
				double point[] = new double[3];double relative[] = new double[3];
				point = VectorAlgebra.addv(ray.ri,VectorAlgebra.mulv(alpha, ray.rd, point),point);
				double norm[] = new double[3];
				double rd[] = new double[3];
				VectorAlgebra.copyv (norm, dc.pl);
				VectorAlgebra.normv(norm);
				VectorAlgebra.copyv (rd, ray.rd);
				VectorAlgebra.normv(rd);
				double cosi = VectorAlgebra.dotv(rd, norm);
				double frt = VectorAlgebra.Ft(cosi, dc.mat.refi);
				boolean wayClear =(dc.mat.refi >= 0.5 && 
						dc.mat.refi<=2.0 &&
						((dc.mtt != null && dc.mtt.pcntshiny(point)>50.0)|| (dc.mtt == null &&dc.mat.pcentmir >50.0)));
				frTransmission *= (wayClear&&lights&&alpha < 1.0?frt:1.0);
				if((!lights ||!wayClear) /*|| frt < 0.02*/) {
					
					if (nearest <=0.0) {
						/* nearest not set with valid value */

						nearest = alpha;
						dbest = dc;
						sbest = null;
						tbest = null;
						cbest = null;
					}

					else if (alpha < nearest) {
						/* nearest is worse than */
						/*new  value */

						nearest = alpha;
						dbest = dc;
						sbest = null;
						tbest = null;
						cbest = null;
					}
				}

			}/* end of valid collision if */

		}/* end of while loop, for dciangle list */


		if (nearest <= 0.0) return (-1.0);  /* nearest invalid the return -1 */

		/* calculate point of collision */
		VectorAlgebra.mulv (nearest, ray.rd, contpt.cc);
		VectorAlgebra.addv (contpt.cc, ray.ri, contpt.cc);

		if (tbest != null) {
			/* if the collision occured with a triangle */
			/* then get normal and material from triangle */

			VectorAlgebra.copyv (contpt.norm, tbest.pl);
			VectorAlgebra.normv(contpt.norm);
			contpt.mat = tbest.mat;
			contpt.mats = null;
			contpt.matt=tbest.matt;
			contpt.matts=tbest.mats;
			contpt.mpc = null;

		}

		else if (sbest != null) {
			/* if the collision occured with a sphere then*/
			/* calculate the normal and get material from */
			/* sphere */

			VectorAlgebra.subv (contpt.cc, sbest.r_cnt, contpt.norm);
			VectorAlgebra.normv(contpt.norm);
			contpt.mat = sbest.mat;
			contpt.mats = sbest.mats;
			contpt.matt = null;
			contpt.matts= null;
			contpt.mpc = null;
		}
		else if (cbest != null) {
			/* if the collision occured with a cylinder then*/
			/* calculate the normal and get material from */
			/* cylinder */

			VectorAlgebra.subv (contpt.cc, cbest.position, contpt.norm);
			double tmp[] = new double[3];double tmp2[] = new double[3];
			VectorAlgebra.mulv(VectorAlgebra.dotv(cbest.uxInv, contpt.norm),cbest.uxInv,tmp);
			VectorAlgebra.mulv(VectorAlgebra.dotv(cbest.uyInv, contpt.norm),cbest.uyInv,tmp2);
			VectorAlgebra.addv(tmp2, tmp, contpt.norm);
			VectorAlgebra.normv(contpt.norm);
			contpt.mat = cbest.mat;
			contpt.mats = null;
			contpt.matt = null;
			contpt.matts = null;
			contpt.mpc = cbest.mpc;
		}
		else if (dbest != null) {
			/* if the collision occured with a cylinder then*/
			/* calculate the normal and get material from */
			/* cylinder */

			VectorAlgebra.copyv (contpt.norm, dbest.pl);
			VectorAlgebra.normv(contpt.norm);
			contpt.mat = dbest.mat;
			contpt.mats = null;
			contpt.matt=dbest.mtt;
			contpt.matts=null;
			contpt.mpc = null;
		}

		else {  /* should never happen for a valid scene */

			System.out.println ("\n Error No Objects found in contact \n");
			System.exit (1);
		}
		contpt.frTransmission = frTransmission;
		return (nearest);
	}

	/******************************************************************************/
	/*                                                                            */
	/* FUNCTION : rtcol()                                                         */
	/*                                                                            */
	/* RETURNED VALUE : positive value if the collision is valid. The magnitude   */
	/* is used to calculate the collision point.                                  */
	/*                                                                            */
	/* DESCRIPTION : This function evaluates if a collision with a plane has      */
	/* occured, and then checks if this collision is within the triangle.         */
	/*                                                                            */
	/* FUNCTIONS CALLED :  rpcol() mulv() addv()                                  */
	/*                                                                            */
	/* RELATED DOCUMENTS :                                                        */
	/*                                                                            */
	/******************************************************************************/


	private static double rtcol(double ri[], double rd[],Triangle tr)

	/* ray start and direction */
	/* pointer to triangle */

	{
		double alpha;            /* value returned by rpcol() */
		double colco[]=new double[3];         /* collision co-ordinate */
		double lhs;              /* left hand side cartesian eqn of a plane */
		double rhs;              /* right hand side cartesian eqn of a plane */

		alpha = VectorAlgebra.rpcol (ri, rd, tr.pl); /* find rays collision with plane */
		if (alpha <= 0.0) return (-1.0);

		VectorAlgebra.mulv (alpha, rd, colco);        /*using alpha value workout collision*/
		VectorAlgebra.addv (colco, ri, colco);        /* co-ordinate */

		/* work out if collision is above */
		/* edge1 bounding plane */

		lhs = tr.e1[0] * colco[0] + tr.e1[1] * colco[1] + tr.e1[2] * colco[2];
		rhs = tr.e1[3];

		if (lhs < rhs) return (-1.0);     /* no collision pt below */

		/* work out if collision is above */
		/* edge2 bounding plane */

		lhs = tr.e2[0] * colco[0] + tr.e2[1] * colco[1] + tr.e2[2] * colco[2];
		rhs = tr.e2[3];

		if (lhs < rhs) return (-1.0);     /* no collision pt below */

		/* work out if collision is above */
		/* edge3 bounding plane */

		lhs = tr.e3[0] * colco[0] + tr.e3[1] * colco[1] + tr.e3[2] * colco[2];
		rhs = tr.e3[3];

		if (lhs < rhs) return (-1.0);     /* no collision pt below */

		return(alpha);
	}
}

